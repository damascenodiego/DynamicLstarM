(define-sort State () Int)
(define-sort Input () Int)
(define-sort Output () Int)

(declare-fun NextState (State Input) State)
(declare-fun TheOutput (State Input) Output)
(declare-fun Transition (State Input Output State) Bool)
(declare-fun Separe (State State Input) Bool)

; initialize transitions
(assert (forall ((x State) (i Input) (o Output) (y State)) (
  => (Transition x i o y)
    (and (= y (NextState x i)) (= o (TheOutput x i)) ))))

; the minimal property
(assert (forall ((x1 State) (y1 State) 
    (i1 Input) (i2 Input) ) ( 
  or
     ;(chain 1)
     (=> (and 
        (= false (Separe x1 y1 i1)) 
        (not (= x1 y1)) 
        (not (= i1 i2))  
     )  
     (= true (Separe x1 y1 i2))
     ) 
     ;(chain 2)
     (forall ((x2 State)(y2 State))
       (=> (and 
              ; base
              (= false (Separe x1 y1 i1)) 
              (= false (Separe x1 y1 i2)) 
              (not (= x1 y1))  
              (not (= i1 i2)) 
              ; block 2
              (= x2 (NextState x1 i1))
              (= y2 (NextState y1 i1)) 
              (not (= x2 y2)) 
              (not (and (= x1 x2) (= y1 y2))) 
           )
           (=> (and 
               (= false (Separe x2 y2 i1)) 
               (not (= x2 y2)) 
               (not (= i1 i2)) 
             )  
             (= true (Separe x2 y2 i2)) 
           )  
       )
     )
     ;(chain 3)
     (forall ((x2 State)(y2 State)(x3 State)(y3 State))
       (=> (and 
              ; base
              (= false (Separe x1 y1 i1)) 
              (= false (Separe x1 y1 i2)) 
              (not (= x1 y1))  
              (not (= i1 i2)) 
              ; block 2
              (= x2 (NextState x1 i1))
              (= y2 (NextState y1 i1)) 
              (not (= x2 y3)) 
              (not (and (= x1 x2) (= y1 y2))) 
	      		(= false (Separe x2 y2 i1)) 
              (= false (Separe x2 y2 i2))
              ; block 3
              (= x3 (NextState x2 i1))
              (= y3 (NextState y2 i1)) 
              (not (= x3 y3)) 
              (not (and (= x2 x3) (= y2 y3))) 
           )
           (=> (and 
               (= false (Separe x3 y3 i1)) 
               (not (= x3 y3)) 
               (not (= i1 i2)) 
             )  
             (= true (Separe x3 y3 i2)) 
           )  
       )
     )
     ;(chain 4)
     (forall ((x2 State)(y2 State)(x3 State)(y3 State)(x4 State)(y4 State))
       (=> (and 
              ; base
              (= false (Separe x1 y1 i1)) 
              (= false (Separe x1 y1 i2)) 
              (not (= x1 y1))  
              (not (= i1 i2)) 
              ; block 2
              (= x2 (NextState x1 i1))
              (= y2 (NextState y1 i1)) 
              (not (= x2 y4)) 
              (not (and (= x1 x2) (= y1 y2))) 
	      		(= false (Separe x2 y2 i1)) 
              (= false (Separe x2 y2 i2))
              ; block 3
              (= x3 (NextState x2 i1))
              (= y3 (NextState y2 i1)) 
              (not (= x3 y4)) 
              (not (and (= x2 x3) (= y2 y3))) 
	      		(= false (Separe x3 y3 i1)) 
              (= false (Separe x3 y3 i2))
              ; block 4
              (= x4 (NextState x3 i1))
              (= y4 (NextState y3 i1)) 
              (not (= x4 y4)) 
              (not (and (= x3 x4) (= y3 y4))) 
           )
           (=> (and 
               (= false (Separe x4 y4 i1)) 
               (not (= x4 y4)) 
               (not (= i1 i2)) 
             )  
             (= true (Separe x4 y4 i2)) 
           )  
       )
     )
  )))
; the mapping is handled by java implementation
(assert (Transition 1 1 1 1))
(assert (Transition 1 2 1 2))
(assert (Transition 2 2 2 1))
(assert (Transition 2 1 2 3))
(assert (Transition 3 2 2 2))
(assert (Transition 4 2 2 3))
(assert (Transition 5 2 2 4))
(assert (= true (Separe 1 2 1 )))
(assert (= true (Separe 1 2 2 )))
(assert (= false (Separe 1 3 1 )))
(assert (= true (Separe 1 3 2 )))
(assert (= false (Separe 1 4 1 )))
(assert (= true (Separe 1 4 2 )))
(assert (= false (Separe 1 5 1 )))
(assert (= true (Separe 1 5 2 )))
(assert (= false (Separe 2 3 1 )))
(assert (= false (Separe 2 3 2 )))
(assert (= false (Separe 2 4 1 )))
(assert (= false (Separe 2 4 2 )))
(assert (= false (Separe 2 5 1 )))
(assert (= false (Separe 2 5 2 )))
(assert (= false (Separe 3 4 1 )))
(assert (= false (Separe 3 4 2 )))
(assert (= false (Separe 3 5 1 )))
(assert (= false (Separe 3 5 2 )))
(assert (= false (Separe 4 5 1 )))
(assert (= false (Separe 4 5 2 )))
(check-sat)
